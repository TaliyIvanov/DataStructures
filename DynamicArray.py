"""
Реализуйте класс динамический массив, имеющий методы:
- push_back(element) - Добавляет элемент в конец массива. Работает амортизировано за O(1)
- pop_back() - Удаляет элемент, находящийся в конце массива, а также возвращающий значение удаленного элемента
- size() - Возвращает количество элементов в массиве.
- capacity() - Возвращает число элементов, которое массив может содержать без выделения дополнительного пространства.

Также должен быть реализован метод взятия и изменения элемента по индексу - по [] - как у стандартного массива.
"""


# Класс, реализующий динамический массив (аналог list в Python, но с ручным управлением памятью).
class MyDynamicArray:
    # Инициализатор класса.
    def __init__(self):
        # _size: Хранит текущее количество элементов, фактически находящихся в массиве.
        # Начинается с 0, так как массив изначально пуст.
        self._size = 0
        # _capacity: Хранит текущую выделенную емкость внутреннего массива (_array).
        # Это максимальное количество элементов, которое может вместить массив БЕЗ перераспределения памяти.
        # Начинается с 1.
        self._capacity = 1
        # array: Внутренний список Python фиксированного размера, используемый для хранения элементов.
        # Инициализируется списком из одного элемента None.
        self.array = [None] * self._capacity

    # Возвращает текущее количество элементов в массиве.
    def size(self):
        return self._size

    # Возвращает текущую выделенную емкость массива.
    def capacity(self):
        return self._capacity

    # Добавляет элемент в конец динамического массива.
    def push_back(self, item):
        # Проверка: если текущее количество элементов равно емкости,
        # значит, во внутреннем массиве нет свободного места.
        if self._size == self._capacity:
            # Необходимо увеличить размер внутреннего массива.
            # Вызываем приватный метод _resize, удваивая текущую емкость.
            self._resize(2 * self._capacity)
        # Теперь место гарантированно есть. Добавляем элемент на позицию _size.
        # (Так как индексы начинаются с 0, _size указывает на первый свободный слот).
        self.array[self._size] = item
        # Увеличиваем счетчик фактического количества элементов.
        self._size += 1

    # Удаляет и возвращает последний элемент из динамического массива.
    def pop_back(self):
        # Проверка: если массив пуст (_size == 0), удалять нечего.
        if self._size == 0:
            # Выбрасываем исключение IndexError, стандартное поведение для таких случаев.
            raise IndexError("Cannot pop from empty array")
        # Получаем последний элемент (индекс _size - 1).
        item = self.array[self._size - 1]
        # Опционально: очищаем ячейку, где был элемент (заменяем на None).
        # Это может помочь сборщику мусора, если на элемент нет других ссылок.
        self.array[self._size - 1] = None
        # Уменьшаем счетчик фактического количества элементов.
        self._size -= 1
        # Возвращаем удаленный элемент.
        # Примечание: Текущая реализация не уменьшает емкость (_capacity) при удалении.
        # В некоторых реализациях добавляют логику сжатия массива при _size << _capacity.
        return item

    # Приватный вспомогательный метод для изменения размера внутреннего массива.
    def _resize(self, new_capacity):
        # Создаем новый список Python (_new_array) с заданной новой емкостью.
        new_array = [None] * new_capacity
        # Копируем элементы из старого массива (self.array) в новый (_new_array).
        # Копируем только существующие элементы (до _size).
        for i in range(self._size):
            new_array[i] = self.array[i]
        # Заменяем старый внутренний массив на новый, увеличенного размера.
        self.array = new_array
        # Обновляем атрибут _capacity, чтобы он соответствовал новой емкости.
        self._capacity = new_capacity

    # Магический метод для получения элемента по индексу (например, my_array[index]).
    def __getitem__(self, index):
        # Проверяем, находится ли запрошенный индекс в допустимых границах.
        # Допустимые индексы: от 0 включительно до _size (текущее количество элементов) не включительно.
        if not 0 <= index < self._size:
            # Если индекс некорректен, выбрасываем IndexError.
            raise IndexError("Index out of bounds")
        # Возвращаем элемент из внутреннего массива по указанному индексу.
        return self.array[index]

    # Магический метод для установки значения элемента по индексу (например, my_array[index] = value).
    def __setitem__(self, index, value):
        # Проверяем, находится ли запрошенный индекс в допустимых границах.
        # Мы можем изменять только существующие элементы (индексы от 0 до _size - 1).
        # Нельзя использовать этот метод для добавления новых элементов за пределы _size.
        if not 0 <= index < self._size:
            # Если индекс некорректен, выбрасываем IndexError.
            raise IndexError("Index out of bounds")
        # Присваиваем новое значение элементу во внутреннем массиве по указанному индексу.
        self.array[index] = value


def process_commands():
    arr = MyDynamicArray()
    n = int(input())
    for _ in range(n):
        command = input().strip()
        if command == "push_back":
            value = int(input())
            arr.push_back(value)
        elif command == "pop_back":
            print(arr.pop_back())
        elif command == "size":
            print(arr.size())
        elif command == "index":
            index = int(input())
            print(arr[index])


if __name__ == "__main__":
    process_commands()

